import numpy as np


class shot_stats:
    '''
    Takes in a DataFrame of shot data generated by target_reader.py and
    calculates statistics necessary for display in the Shot Plot Flask app.
    Compiled data is available in dict form for compatibility with Flask.
    '''

    # Class-wide settings
    min_hmap_value = .9             # HSV value for heatmap minimum
    max_hmap_value = .25            # HSV value for heatmap maximum

    def __init__(self, trg_size, orig_score_step, orig_out_width):
        '''
        Initializes class variables

        Args:
            trg_size (int): height/width of target display in pixels
            score_step (float): difference in radius between target circles

        Returns:
            None
        '''
        self.trg_size = trg_size
        self.shot_size = trg_size / 100
        self.score_step = trg_size * orig_score_step / orig_out_width
        self.scale_factor = trg_size / orig_out_width

        # Initializes output variables
        self.shots = None
        self.stats = None
        return None

    def run(self, df):
        '''
        Calculates all shot statistics and saves them in class variables

        Args:
            df (Pandas DataFrame): shot data from target_reader.py

        Returns:
            None if successful, str containing error message if not
        '''
        # Corrects coordinates for display dimensions
        df = df.copy(deep=True)
        for col in ['x', 'y', 'error', 'op_x', 'op_y']:
            df[col] *= self.scale_factor
        self.shots = df.to_dict(orient='records')

        # Calculates summary statistics
        num_shots = df.shape[0]
        mean_score = round(df['score'].mean(), 2)
        mean_op_score = round(df['op_score'].mean(), 2)
        mean_error = round(df['error'].mean(), 2)

        # Calculates values for score and coordinate heatmaps
        score_hist, score_hmap = self.disc_to_hist(df['score'])
        op_score_hist, op_score_hmap = self.disc_to_hist(df['op_score'])
        x_hist, x_hmap = self.cont_to_hist(df['x'])
        y_hist, y_hmap = self.cont_to_hist(df['y'])

        # Compiles recommendation list
        reco_list = self.get_reco_list(df['x'],
                                       df['y'],
                                       mean_score,
                                       mean_op_score)

        # Packages all statistics into a dict
        self.stats = {
            'trg_size': self.trg_size,
            'shot_size': self.shot_size,
            'score_step': self.score_step,
            'num_shots': num_shots,
            'mean_score': mean_score,
            'mean_op_score': mean_op_score,
            'mean_error': mean_error,
            'recos': reco_list,
            'score_hist': score_hist,
            'score_hmap': score_hmap,
            'op_score_hist': op_score_hist,
            'op_score_hmap': op_score_hmap,
            'x_hist': x_hist,
            'x_hmap': x_hmap,
            'y_hist': y_hist,
            'y_hmap': y_hmap
        }
        return None

    def disc_to_hist(self, series, bin_min=0, bin_max=10, bin_step=1):
        '''
        Derives a histogram and corresponding heatmap values from a Pandas
        series of discrete values. Intended for use on shot scores.

        Args:
            series (Pandas Series): a series of discrete, binable values
            bin_min (int): the smallest bin value
            bin_max (int): the largest bin value
            bin_step (int): the step value between bins

        Returns:
            list (int): histogram of series as a list with indices as bins
            list (float): heatmap color values corresponding to histogram
        '''
        as_dict = series.value_counts().to_dict()
        hist = [as_dict.get(x, 0) for x in range(bin_min, bin_max+1, bin_step)]
        hmap = np.interp(hist,
                         (0, max(hist)),
                         (self.min_hmap_value, self.max_hmap_value))
        return hist, hmap.tolist()

    def cont_to_hist(self, series, bin_min=0, bin_max=None, num_bins=11):
        '''
        Derives a histogram and corresponding heatmap values from a Pandas
        series of continuous values. Intended for use on shot coordinates.

        Args:
            series (Pandas Series): a series of continuous, binable values
            bin_min (int): the smallest bin value
            bin_max (int): the largest bin value
            num_bins (int): the number of bins between bin_min and bin_max

        Returns:
            list (int): histogram of series as a list with indices as bins
            list (float): heatmap color values corresponding to histogram
        '''
        if bin_max == None:
            bin_max = self.trg_size
        bins = np.linspace(bin_min, bin_max, num_bins, endpoint=False)[1:]
        bin_vals = np.searchsorted(bins, series)
        hist = np.bincount(bin_vals, minlength=num_bins)
        hmap = np.interp(hist,
                         (0, max(hist)),
                         (self.min_hmap_value, self.max_hmap_value))
        return hist.tolist(), hmap.tolist()

    def get_reco_list(self, x_vals, y_vals, actual_score, op_score):
        '''
        Compiles a list of archer recommendations based on shooting statistics

        Args:
            x_vals (Pandas Series): x components of shot coordinates
            y_vals (Pandas Series): y components of shot coordinates
            actual_score (float): mean shot score
            op_score (float): optimized mean shot score

        Returns:
            list (str): archer recommendations
        '''
        # Recommendation string fragments
        op_str = (
            'Your optimized score is significantly higher than your actual '
            'score, which means you are grouping better than your score '
            'indicates. Adjusting your sights may help you shoot better.')
        grp_base_str = 'Your %s grouping %s'
        grp_hori_str = 'horizontal'
        grp_vert_str = 'vertical'
        grp_both_1_str = 'is great! Keep up the good work!'
        grp_hori_2_str = (
            'is decent. Make sure your bow hand is steady and that you\'re '
            'pulling your release straight back and aren\'t plucking the '
            'bowstring.')
        grp_hori_3_str = (
            'needs work. Make sure you\'re holding your bow steadily through '
            'your shot. As you release you should be pulling your hand '
            'straight back across the side of your face.')
        grp_vert_2_str = (
            'is all right. Make sure your bow hand is steady, your anchor '
            'point is consistent, and that you\'re reaching full draw before '
            'releasing.')
        grp_vert_3_str = (
            'could be better. Make sure you\'re holding your bow steadily '
            'through your shot and aren\'t catching it as you release. You '
            'should also work on finding a consistent anchor point in order to '
            'improve your aim.')

        # Recommendation thresholds
        op_thresh = 1.1
        grp_thresh = [.1, .15, 1]

        # Combines recommendations into lists for easy selection
        grp_hori_all_str = [grp_both_1_str, grp_hori_2_str, grp_hori_3_str]
        grp_vert_all_str = [grp_both_1_str, grp_vert_2_str, grp_vert_3_str]
        reco_list = []

        # Uses standard deviation to determine grouping recommendations
        hori_std = x_vals.std()
        hori_idx = np.searchsorted(grp_thresh, hori_std/self.trg_size)
        hori_reco = grp_base_str % (grp_hori_str, grp_hori_all_str[hori_idx])
        vert_std = y_vals.std()
        vert_idx = np.searchsorted(grp_thresh, vert_std/self.trg_size)
        vert_reco = grp_base_str % (grp_vert_str, grp_vert_all_str[vert_idx])

        # Orders final recommendations list
        if op_score > actual_score * op_thresh:
            reco_list.append(op_str)
        if hori_std > vert_std:
            reco_list.extend([hori_reco, vert_reco])
        else:
            reco_list.extend([vert_reco, hori_reco])
        return reco_list
